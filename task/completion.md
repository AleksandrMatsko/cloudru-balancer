# Прогресс выполнения задания

## 1. Вопросы для разогрева

Ответил в письме на электронную почту, туда же прикрепил ссылку на этот репозиторий

---

## 2. Разработка HTTP-балансировщика нагрузки на Go
### Часть 1. Балансировщик нагрузки
**Основной функционал:**
- [x] Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080).
- [x] При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения. **(хосты задаются в конфиге)**
- [x] Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

**Распределение запросов:**
- [x] Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
- [x] Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы). **(возвращает ошибку)**

**Параллелизм и конкурентность:**
- [x] Обеспечить одновременную обработку нескольких запросов с использованием горутин. **(полагаюсь на стандартную библиотеку)**
- [x] Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

**Обработка ошибок:**
- [x] Реализовать обработку ошибок при обращении к бэкендам.
- [x] Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

**Логирование:**
- [x] Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

**Конфигурация:**
- [x] Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки. **(испоьзуется конфигурационный файл в формате .yml, путь до файла может быть изменён через аргументы командной строки)**
- [x] Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

### Часть 2. Реализация Rate-Limiting
Требуется разработать модуль для ограничения частоты запросов (rate-limiting) на основе алгоритма Token Bucket. Модуль должен защищать внутренние сервисы от перегрузок, обеспечивать честное распределение ресурсов между клиентами и корректно обрабатывать высокую нагрузку.

**Функциональные требования:**

**Реализация алгоритма Token Bucket:**
- [ ] Каждому клиенту (IP или API-ключ) выделяется отдельный **bucket** токенов.
- [ ] Настройки bucket: количество токенов (емкость), скорость пополнения.
- [ ] Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.

**Гранулярное ограничение:**
- [ ] Отслеживать состояние каждого клиента (IP/API-ключ)
- [ ] Поддерживать возможность настройки разных лимитов для разных клиентов.
- [ ] Настройки для разных клиентов можно сохранять в базе данных

**Автоматическое пополнение токенов:**
- [ ] Использовать `time.Ticker` для периодического пополнения токенов в buckets.
- [ ] Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).

**Конкурентность:**
- [ ] Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
- [ ] Обеспечить минимальные блокировки для максимизации производительности.

**Документация**
- [x] Требуется подготовить README с описанием сборки и запуска проекта.

### Будет здорово, если:
- [x] Архитектура проекта будет модульной: разделите код на логически обособленные пакеты (например, для логики распределения, работы с конфигурацией и реализации HTTP-сервера).
- Приветствуется чистота кода, понятное и подробное комментирование, а также применение интерфейсов для упрощения замены реализаций.
- Оценка задания будет проводиться не только на основе реализованного функционала, но и на основе качества кода (структурирование, тестируемость, документация).
- [x] Напишите Dockerfile и docker-compose.yml для развертывания сервиса и БД 
- Добавите интеграционные тесты с использованием `go test -bench=. -race`.
- Пример нагрузки через Apache Bench (`ab -n 5000 -c 1000 http://localhost:8080/`).


### Дополнительные пункты для размышления
**Поддержка нескольких алгоритмов распределения:**
- [x] Помимо round-robin, реализовать или предусмотреть возможность использования алгоритмов «least connections» или случайного распределения запросов. **(сделал случайный)**

**Здоровье бэкендов (Health Checks):**
- [x] Добавить механизм периодических проверок состояния каждого бэкенд-сервера.
- [x] При обнаружении недоступного сервера временно исключать его из пула, а при восстановлении работы возвращать обратно.

**Graceful Shutdown:**
- [x] Реализовать корректное завершение работы балансировщика (обработка сигнала SIGINT или SIGTERM), чтобы завершить обработку текущих запросов без потери данных.

**CRUD для управления клиентами:**
- [ ] API для добавления/удаления клиентов (IP/API-ключей) и настройки их лимитов.
- Пример эндпоинта:
    `POST /clients { "client_id": "user1", "capacity": 100, "rate_per_sec": 10 }`

**Персистентность:**
- [ ] Сохранять состояние клиентов (текущие токены, настройки) в БД или файле.
- [ ] Использовать конфигурационный файл для дефолтных лимитов.

**Обработка ошибок:**
- [x] Возвращать структурированные JSON-ошибки с кодом и описанием.
- Пример:
    `{ "code": 429, "message": "Rate limit exceeded" }`

